<?php
/* ***********************************************************************************************
 *
 * Phoebius Framework
 *
 * **********************************************************************************************
 *
 * Copyright (c) 2009 Scand Ltd.
 *
 * This program is free software; you can redistribute it and/or modify it under the terms
 * of the GNU Lesser General Public License as published by the Free Software Foundation;
 * either version 3 of the License, or (at your option) any later version.
 *
 * You should have received a copy of the GNU Lesser General Public License along with
 * this program; if not, see <http://www.gnu.org/licenses/>.
 *
 ************************************************************************************************/

/**
 * Represents fundamental type.
 *
 * Base types MUST BE implemented by the database drivers.
 * These type can have precision, scale and size, or may omit those tuning; the database drivers
 * MUST be able handle those cases IMPLICITLY.
 *
 * @ingroup Dal_DB
 */
final class DBType extends Enumeration implements ISqlType
{
	// primitive
	const BOOLEAN = 'boolean';

	// integers
	const INT16 = 'int16';
	const INT32 = 'int32';
	const INT64 = 'int64';

	// unsigned integers
	const UINT16 = 'uint16';
	const UINT32 = 'uint32';
	const UINT64 = 'uint64';

	// floating-point
	const CURRENCY = 'currency';
	const DECIMAL = 'decimal';
	const FLOAT = 'float';

	// string
	const BINARY = 'binary';
	const CHAR = 'char';
	const VARCHAR = 'varchar';

	// date and time
	const DATE = 'date';
	const TIME = 'time';
	const DATETIME = 'datetime';

	private static $hasSize = array(
		self::VARCHAR, self::CHAR, self::BINARY
	);

	private static $hasPrecision = array(
		self::CURRENCY, self::DECIMAL, self::FLOAT
	);

	private static $hasScale = array(
		self::CURRENCY, self::DECIMAL
	);

	private static $canBeGenerated = array(
		self::UINT16, self::UINT32, self::UINT64
	);

	private $isNullable = false;
	private $isGenerated = false;

	private $size;
	private $precision;
	private $scale;

	/**
	 * DBType static constructor
	 *
	 * @param string $id one of DBType constants
	 * @param boolean $nullable optional whether type is nullable; default is NOT NULL
	 * @param int|null $size size of a type, if the type can have size; by default size is not set
	 * @param int|null $precision precision of a type, if the type can have precision; by default precision is not set
	 * @param int|null $scale scale of a type, if the type can have scale; by default scale is not set
	 * @param boolean $generated whether type can be generated by the database; by default is not
	 *
	 * @return DBType
	 */
	static function create(
			$id,
			$nullable = false,
			$size = null,
			$precision = null,
			$scale = null,
			$generated = false
		)
	{
		return new self ($id, $nullable, $size, $precision, $scale, $generated);
	}

	/**
	 * Determines whether DBType has type identified by the specified $id
	 *
	 * @param mixed $id
	 *
	 * @return boolean
	 */
	static function hasMember($id)
	{
		try {
			new self ($id);

			return true;
		}
		catch (Exception $e) {
			return false;
		}
	}

	/**
	 * @param string $id one of DBType constants
	 * @param boolean $nullable optional whether type is nullable; default is NOT NULL
	 * @param int|null $size size of a type, if the type can have size; by default size is not set
	 * @param int|null $precision precision of a type, if the type can have precision; by default precision is not set
	 * @param int|null $scale scale of a type, if the type can have scale; by default scale is not set
	 * @param boolean $generated whether type can be generated by the database; by default is not
	 */
	function __construct(
			$id,
			$nullable = false,
			$size = null,
			$precision = null,
			$scale = null,
			$generated = false
		)
	{
		parent::__construct($id);

		$this->setIsNullable($nullable);

		if ($this->canHaveSize()) {
			$this->setSize($size);
		}
		else if ($this->canHavePrecision()) {
			$this->setPrecision($precision);

			if ($this->canHaveScale()) {
				$this->setScale($scale);
			}
		}

		if ($this->canBeGenerated()) {
			$this->setGenerated($generated);
		}
	}

	/**
	 * Gets the OrmPropertyType that corresponds current DBType
	 *
	 * @return OrmPropertyType
	 */
	function getOrmPropertyType()
	{
		switch ($this->getValue()) {
			case self::DATE: {
				return new BoxablePropertyType('Date', $this);
			}
			case self::TIME: {
				return new BoxablePropertyType('Time', $this);
			}
			case self::DATETIME: {
				return new BoxablePropertyType('Timestamp', $this);
			}
			default: { // booleans' special case is handled internally
				return new FundamentalPropertyType($this);
			}
		}
	}

	/**
	 * Determines whether DBType can have size
	 *
	 * @return boolean
	 */
	function canHaveSize()
	{
		return in_array($this->getValue(), self::$hasSize);
	}

	/**
	 * Determines wheter DBType can have precision
	 *
	 * @return boolean
	 */
	function canHavePrecision()
	{
		return in_array($this->getValue(), self::$hasPrecision);
	}

	/**
	 * Determines whether DBType can have scale
	 *
	 * @return boolean
	 */
	function canHaveScale()
	{
		return in_array($this->getValue(), self::$hasScale);
	}

	/**
	 * Determines whether DBType can be generated by the DB
	 *
	 * @return boolean
	 */
	function canBeGenerated()
	{
		return in_array($this->getValue(), self::$canBeGenerated);
	}

	/**
	 * Gets the size of DBType, if set.
	 *
	 * @return int|null
	 */
	function getSize()
	{
		return $this->size;
	}

	/**
	 * Gets the precision of DBType, if set
	 *
	 * @return int|null
	 */
	function getPrecision()
	{
		return $this->precision;
	}

	/**
	 * Gets the scale of DBType, if set
	 *
	 * @return int|null
	 */
	function getScale()
	{
		return $this->scale;
	}

	/**
	 * Determines whether DBType is generated
	 *
	 * @return boolean
	 */
	function isGenerated()
	{
		return $this->isGenerated;
	}

	/**
	 * Sets the size of DBType or cleans the size, if possible
	 *
	 * @param int|null $size new size of the type
	 *
	 * @return DBType itself
	 */
	function setSize($size = null)
	{
		if (!$this->canHaveSize()) {
			$size = null;
		}

		if (!is_null($size)) {
			$size = abs((int) $size);
		}

		$this->size = $size;

		return $this;
	}

	/**
	 * Sets the precision of DBType or cleans the precision, if possible
	 *
	 * @param int|null $precision new precision of the type
	 *
	 * @return DBType itself
	 */
	function setPrecision($precision = null)
	{
		if (!$this->canHavePrecision()) {
			$this->precision = null;
		}

		if (!is_null($precision)) {
			$size = abs((int) $precision);
		}

		$this->precision = $precision;

		return $this;
	}

	/**
	 * Sets the scale of DBType or cleans previously set scale, if possible
	 *
	 * @param int|null $scale new scale of the type
	 *
	 * @return DBType itself
	 */
	function setScale($scale = null)
	{
		if (!$this->canHaveScale()) {
			$scale = null;
		}

		if (!is_null($scale)) {
			$size = abs((int) $scale);
		}

		$this->scale = $scale;

		return $this;
	}

	/**
	 * Defines the type as generated or not, if possbile
	 * @param boolean $flag
	 *
	 * @return DBType itself
	 */
	function setGenerated($flag)
	{
		if (!$this->canBeGenerated()) {
			$flag = false;
		}

		Assert::isBoolean($flag);

		$this->isGenerated = $flag;

		return $this;
	}

	/**
	 * Defines the type as nullable or not, if possible
	 *
	 * @param boolean $flag
	 *
	 * @return DBType
	 */
	function setIsNullable($flag)
	{
		Assert::isBoolean($flag);

		$this->isNullable = $flag;

		return $this;
	}

	/**
	 * Determines whether DBType is nullable
	 *
	 * @return boolean
	 */
	function isNullable()
	{
		return $this->isNullable;
	}

	function toDialectString(IDialect $dialect)
	{
		return $dialect->getTypeRepresentation($this);
	}

	/**
	 * Gets the textual representation of PHP-compatible code that is responsible for creating
	 * a new instance of DBType
	 *
	 * @return string
	 */
	function toPhpCodeCall()
	{
		return
			'new DBType('.
				join(', ', array(
					'DBType::' . $this->getId(),
					$this->isNullable ? 'true' : 'false',
					null != $this->size ? $this->size : 'null',
					null != $this->precision ? $this->precision : 'null',
					null != $this->scale ? $this->scale : 'null',
					$this->isGenerated ? 'true' : 'false',
				))
			. ')';
	}
}

?>